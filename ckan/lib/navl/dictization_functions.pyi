import json
from typing import (
    Any,
    Callable,
    Dict,
    Iterable,
    List,
    NoReturn,
    Optional,
    Set,
    Tuple,
)

class Missing(object):
    def __str__(self) -> NoReturn: ...
    def __int__(self) -> NoReturn: ...
    def __complex__(self) -> NoReturn: ...
    def __long__(self) -> NoReturn: ...
    def __float__(self) -> NoReturn: ...
    def __oct__(self) -> NoReturn: ...
    def __hex__(self) -> NoReturn: ...
    def __len__(self) -> int: ...

missing: Missing

class State(object): ...

class DictizationError(Exception):
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...

class Invalid(DictizationError):
    def __init__(self, error: str, key: Optional[Any] = ...) -> None: ...

class DataError(DictizationError):
    def __init__(self, error: str) -> None: ...

class StopOnError(DictizationError): ...

def flattened_order_key(key: Iterable) -> Tuple: ...
def flatten_schema(
    schema: Dict, flattened: Optional[Dict] = ..., key: Optional[List] = ...
) -> Dict[Tuple, Any]: ...
def get_all_key_combinations(
    data: Dict, flattened_schema: Dict[Tuple, Any]
) -> Set[Tuple]: ...
def make_full_schema(data: Dict, schema: Dict) -> Dict: ...
def augment_data(data: Dict, schema: Dict) -> Dict: ...
def convert(
    converter: Callable,
    key: Any,
    converted_data: Dict,
    errors: Dict[str, List],
    context: Dict,
) -> None: ...
def validate(
    data: Dict, schema: Dict, context: Optional[Dict] = ...
) -> Tuple[Dict, Dict]: ...
def flatten_list(
    data: List[Dict],
    flattened: Optional[Dict] = ...,
    old_key: Optional[List] = ...,
) -> Dict: ...
def flatten_dict(
    data: Dict, flattened: Optional[Dict] = ..., old_key: Optional[List] = ...
) -> Dict: ...
def unflatten(data: Dict) -> Dict: ...

class MissingNullEncoder(json.JSONEncoder): ...

def check_dict(
    data_dict: Dict, select_dict: Dict, parent_path: Tuple = ...
) -> List[Tuple]: ...
def check_list(
    data_list: List, select_list: List, parent_path: Tuple = ...
) -> List[Tuple]: ...
def resolve_string_key(data: Dict, string_key: str) -> Tuple[Any, Tuple]: ...
def check_string_key(
    data_dict: Dict, string_key: str, value: Any
) -> List[Tuple]: ...
def filter_glob_match(data_dict: Dict, glob_patterns: List[str]) -> None: ...
def update_merge_dict(
    data_dict: Dict, update_dict: Dict, parent_path: Tuple = ...
) -> None: ...
def update_merge_list(
    data_list: List, update_list: List, parent_path: Tuple = ...
) -> None: ...
def update_merge_string_key(
    data_dict: Dict, string_key: str, value: Any
) -> None: ...
